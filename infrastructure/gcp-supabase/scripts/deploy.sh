#!/bin/bash
# Supabase on GCP Deployment Script
# Deploys self-hosted Supabase infrastructure on Google Cloud Platform

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
TERRAFORM_DIR="$PROJECT_ROOT"
K8S_DIR="$PROJECT_ROOT/k8s"

# Default values
PROJECT_ID=""
REGION="us-central1"
ENVIRONMENT="prod"
DOMAIN="advotecate.com"
SKIP_TERRAFORM=false
SKIP_KUBERNETES=false
DRY_RUN=false

# Functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

show_usage() {
    cat << EOF
Usage: $0 [OPTIONS]

Deploy Supabase infrastructure on Google Cloud Platform

OPTIONS:
    -p, --project-id PROJECT_ID    GCP Project ID (required)
    -r, --region REGION           GCP Region (default: us-central1)
    -e, --environment ENV         Environment (default: prod)
    -d, --domain DOMAIN          Domain name (default: advotecate.com)
    --skip-terraform             Skip Terraform deployment
    --skip-kubernetes            Skip Kubernetes deployment
    --dry-run                    Show what would be deployed without executing
    -h, --help                   Show this help message

EXAMPLES:
    $0 -p my-project-id
    $0 -p my-project-id -r us-west1 -e staging
    $0 -p my-project-id --skip-terraform

REQUIREMENTS:
    - Google Cloud SDK (gcloud) installed and authenticated
    - Terraform >= 1.5 installed
    - kubectl installed
    - Docker installed (for building images)

EOF
}

check_prerequisites() {
    log_info "Checking prerequisites..."

    local missing_tools=()

    # Check gcloud
    if ! command -v gcloud &> /dev/null; then
        missing_tools+=("gcloud")
    fi

    # Check terraform
    if ! command -v terraform &> /dev/null; then
        missing_tools+=("terraform")
    else
        local tf_version=$(terraform version -json | jq -r '.terraform_version')
        if [[ "$(printf '%s\n' "1.5.0" "$tf_version" | sort -V | head -n1)" != "1.5.0" ]]; then
            log_error "Terraform version must be >= 1.5.0 (found: $tf_version)"
            exit 1
        fi
    fi

    # Check kubectl
    if ! command -v kubectl &> /dev/null; then
        missing_tools+=("kubectl")
    fi

    # Check jq
    if ! command -v jq &> /dev/null; then
        missing_tools+=("jq")
    fi

    if [[ ${#missing_tools[@]} -gt 0 ]]; then
        log_error "Missing required tools: ${missing_tools[*]}"
        log_info "Please install the missing tools and try again."
        exit 1
    fi

    log_success "All prerequisites satisfied"
}

validate_gcp_auth() {
    log_info "Validating GCP authentication..."

    if ! gcloud auth list --filter=status:ACTIVE --format="value(account)" | grep -q "@"; then
        log_error "No active GCP authentication found"
        log_info "Please run: gcloud auth login"
        exit 1
    fi

    # Set project
    gcloud config set project "$PROJECT_ID"

    # Verify project exists and we have access
    if ! gcloud projects describe "$PROJECT_ID" &> /dev/null; then
        log_error "Cannot access project $PROJECT_ID"
        log_info "Please verify the project ID and your permissions"
        exit 1
    fi

    log_success "GCP authentication validated for project $PROJECT_ID"
}

create_terraform_tfvars() {
    log_info "Creating terraform.tfvars file..."

    local tfvars_file="$TERRAFORM_DIR/terraform.tfvars"

    cat > "$tfvars_file" << EOF
# Terraform variables for Supabase on GCP deployment
# Generated by deploy script on $(date)

project_id  = "$PROJECT_ID"
region      = "$REGION"
zone        = "$REGION-a"
environment = "$ENVIRONMENT"

# Network configuration
vpc_cidr                     = "10.0.0.0/16"
enable_private_google_access = true
enable_nat_gateway          = true

# GKE configuration
gke_node_count       = 2
gke_max_node_count   = 10
gke_machine_type     = "e2-standard-4"
gke_disk_size        = 100
gke_preemptible     = false

# Cloud SQL configuration
cloudsql_tier                    = "db-custom-4-16384"
cloudsql_disk_size              = 200
cloudsql_availability_type      = "REGIONAL"
cloudsql_backup_enabled         = true
cloudsql_point_in_time_recovery = true

# Security configuration
enable_binary_authorization = true
enable_network_policy      = true
enable_private_nodes       = true
enable_workload_identity   = true

# Monitoring and logging
enable_logging      = true
enable_monitoring   = true
log_retention_days  = 30

# Labels
additional_labels = {
  deployed_by = "terraform"
  domain      = "$DOMAIN"
}

# Cost optimization (set to true for development)
enable_cost_optimization = false
schedule_downscaling     = false
EOF

    log_success "Created terraform.tfvars file"
}

deploy_terraform() {
    if [[ "$SKIP_TERRAFORM" == "true" ]]; then
        log_info "Skipping Terraform deployment"
        return 0
    fi

    log_info "Deploying Terraform infrastructure..."

    cd "$TERRAFORM_DIR"

    # Initialize Terraform
    log_info "Initializing Terraform..."
    terraform init

    # Validate configuration
    log_info "Validating Terraform configuration..."
    terraform validate

    # Plan deployment
    log_info "Planning Terraform deployment..."
    terraform plan -out=tfplan

    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "Dry run mode - stopping before apply"
        return 0
    fi

    # Apply deployment
    log_info "Applying Terraform deployment..."
    terraform apply tfplan

    # Get outputs
    log_info "Retrieving Terraform outputs..."
    terraform output -json > terraform-outputs.json

    log_success "Terraform infrastructure deployed successfully"
}

configure_kubectl() {
    log_info "Configuring kubectl..."

    local cluster_name
    local cluster_location

    if [[ -f "$TERRAFORM_DIR/terraform-outputs.json" ]]; then
        cluster_name=$(jq -r '.gke_cluster_name.value' "$TERRAFORM_DIR/terraform-outputs.json")
        cluster_location=$(jq -r '.gke_cluster_location.value' "$TERRAFORM_DIR/terraform-outputs.json")
    else
        cluster_name="$ENVIRONMENT-supabase-cluster"
        cluster_location="$REGION"
    fi

    # Get cluster credentials
    gcloud container clusters get-credentials "$cluster_name" --region "$cluster_location" --project "$PROJECT_ID"

    # Verify connectivity
    kubectl cluster-info

    log_success "kubectl configured successfully"
}

update_k8s_manifests() {
    log_info "Updating Kubernetes manifests with deployment-specific values..."

    local postgres_ip
    local project_id_safe

    if [[ -f "$TERRAFORM_DIR/terraform-outputs.json" ]]; then
        postgres_ip=$(jq -r '.cloudsql_private_ip.value' "$TERRAFORM_DIR/terraform-outputs.json")
    else
        # Fallback - get from gcloud
        postgres_ip=$(gcloud sql instances describe "$ENVIRONMENT-supabase-postgres" --project="$PROJECT_ID" --format="value(ipAddresses[0].ipAddress)")
    fi

    project_id_safe="${PROJECT_ID//-/_}"  # Replace hyphens with underscores for some contexts

    # Update manifests
    find "$K8S_DIR" -name "*.yaml" -type f -exec sed -i.bak \
        -e "s/POSTGRES_PRIVATE_IP_PLACEHOLDER/$postgres_ip/g" \
        -e "s/PROJECT_ID_PLACEHOLDER/$PROJECT_ID/g" \
        -e "s/ENVIRONMENT_PLACEHOLDER/$ENVIRONMENT/g" \
        -e "s/DOMAIN_PLACEHOLDER/$DOMAIN/g" \
        {} \;

    # Clean up backup files
    find "$K8S_DIR" -name "*.bak" -delete

    log_success "Kubernetes manifests updated"
}

deploy_kubernetes() {
    if [[ "$SKIP_KUBERNETES" == "true" ]]; then
        log_info "Skipping Kubernetes deployment"
        return 0
    fi

    log_info "Deploying Kubernetes resources..."

    # Apply resources in order
    local resources=(
        "namespace.yaml"
        "security.yaml"
        "supabase-config.yaml"
        "supabase-kong.yaml"
        "supabase-services.yaml"
        "krakend-config.yaml"
        "monitoring.yaml"
    )

    for resource in "${resources[@]}"; do
        local resource_path="$K8S_DIR/$resource"

        if [[ -f "$resource_path" ]]; then
            log_info "Applying $resource..."

            if [[ "$DRY_RUN" == "true" ]]; then
                kubectl apply --dry-run=client -f "$resource_path"
            else
                kubectl apply -f "$resource_path"
            fi
        else
            log_warning "Resource file not found: $resource_path"
        fi
    done

    if [[ "$DRY_RUN" == "false" ]]; then
        # Wait for deployments to be ready
        log_info "Waiting for deployments to be ready..."

        kubectl wait --for=condition=available --timeout=600s deployment/kong-gateway -n supabase
        kubectl wait --for=condition=available --timeout=600s deployment/supabase-auth -n supabase
        kubectl wait --for=condition=available --timeout=600s deployment/supabase-rest -n supabase
        kubectl wait --for=condition=available --timeout=600s deployment/krakend-gateway -n krakend

        log_success "Kubernetes resources deployed successfully"
    else
        log_info "Dry run mode - Kubernetes resources validated"
    fi
}

setup_dns() {
    log_info "Setting up DNS records..."

    # Get external IP for the ingress
    local external_ip
    external_ip=$(kubectl get ingress krakend-ingress -n krakend -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")

    if [[ -z "$external_ip" ]]; then
        log_warning "External IP not yet available. DNS setup skipped."
        log_info "Please manually create DNS A records pointing to the LoadBalancer IP:"
        log_info "  - api.$DOMAIN"
        log_info "  - supabase.$DOMAIN"
        log_info "  - monitoring.$DOMAIN"
        return 0
    fi

    log_info "LoadBalancer External IP: $external_ip"
    log_info "Please create the following DNS A records:"
    log_info "  - api.$DOMAIN -> $external_ip"
    log_info "  - supabase.$DOMAIN -> $external_ip"
    log_info "  - monitoring.$DOMAIN -> $external_ip"
}

show_deployment_info() {
    log_success "Deployment completed successfully!"

    echo
    echo "=== Deployment Information ==="
    echo "Project ID: $PROJECT_ID"
    echo "Region: $REGION"
    echo "Environment: $ENVIRONMENT"
    echo "Domain: $DOMAIN"
    echo

    if [[ -f "$TERRAFORM_DIR/terraform-outputs.json" ]]; then
        echo "=== Infrastructure Details ==="
        echo "GKE Cluster: $(jq -r '.gke_cluster_name.value' "$TERRAFORM_DIR/terraform-outputs.json")"
        echo "Database: $(jq -r '.cloudsql_instance_name.value' "$TERRAFORM_DIR/terraform-outputs.json")"
        echo "VPC Network: $(jq -r '.vpc_name.value' "$TERRAFORM_DIR/terraform-outputs.json")"
        echo
    fi

    echo "=== Service URLs ==="
    echo "API Gateway: https://api.$DOMAIN"
    echo "Supabase Dashboard: https://supabase.$DOMAIN"
    echo "Monitoring Dashboard: https://monitoring.$DOMAIN"
    echo

    echo "=== Next Steps ==="
    echo "1. Configure DNS records (see output above)"
    echo "2. Wait for SSL certificates to be provisioned (15-30 minutes)"
    echo "3. Test the API endpoints"
    echo "4. Configure your frontend applications to use the new API endpoint"
    echo

    echo "=== Useful Commands ==="
    echo "Check pod status: kubectl get pods -A"
    echo "View logs: kubectl logs -f deployment/krakend-gateway -n krakend"
    echo "Access Grafana: kubectl port-forward -n supabase svc/grafana 3000:3000"
    echo
}

cleanup_on_exit() {
    if [[ $? -ne 0 ]]; then
        log_error "Deployment failed!"
        echo
        echo "=== Troubleshooting ==="
        echo "Check the logs above for specific error messages."
        echo "Common issues:"
        echo "1. Insufficient GCP permissions"
        echo "2. Resource quotas exceeded"
        echo "3. Invalid configuration values"
        echo
        echo "=== Cleanup ==="
        echo "To clean up partially deployed resources:"
        echo "kubectl delete ns supabase krakend"
        echo "cd $TERRAFORM_DIR && terraform destroy"
    fi
}

main() {
    trap cleanup_on_exit EXIT

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -p|--project-id)
                PROJECT_ID="$2"
                shift 2
                ;;
            -r|--region)
                REGION="$2"
                shift 2
                ;;
            -e|--environment)
                ENVIRONMENT="$2"
                shift 2
                ;;
            -d|--domain)
                DOMAIN="$2"
                shift 2
                ;;
            --skip-terraform)
                SKIP_TERRAFORM=true
                shift
                ;;
            --skip-kubernetes)
                SKIP_KUBERNETES=true
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            -h|--help)
                show_usage
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                show_usage
                exit 1
                ;;
        esac
    done

    # Validate required arguments
    if [[ -z "$PROJECT_ID" ]]; then
        log_error "Project ID is required"
        show_usage
        exit 1
    fi

    # Start deployment
    log_info "Starting Supabase on GCP deployment..."
    log_info "Project: $PROJECT_ID, Region: $REGION, Environment: $ENVIRONMENT"

    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "DRY RUN MODE - No actual resources will be created"
    fi

    check_prerequisites
    validate_gcp_auth
    create_terraform_tfvars
    deploy_terraform

    if [[ "$SKIP_KUBERNETES" == "false" ]]; then
        configure_kubectl
        update_k8s_manifests
        deploy_kubernetes
        setup_dns
    fi

    show_deployment_info
}

# Run main function
main "$@"